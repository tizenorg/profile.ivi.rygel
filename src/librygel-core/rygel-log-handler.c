/* rygel-log-handler.c generated by valac 0.18.0, the Vala compiler
 * generated from rygel-log-handler.vala, do not modify */

/*
 * Copyright (C) 2008 Nokia Corporation.
 *
 * Author: Zeeshan Ali (Khattak) <zeeshanak@gnome.org>
 *                               <zeeshan.ali@nokia.com>
 *
 * This file is part of Rygel.
 *
 * Rygel is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Rygel is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>


#define RYGEL_TYPE_LOG_LEVEL (rygel_log_level_get_type ())

#define RYGEL_TYPE_LOG_HANDLER (rygel_log_handler_get_type ())
#define RYGEL_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandler))
#define RYGEL_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))
#define RYGEL_IS_LOG_HANDLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_LOG_HANDLER))
#define RYGEL_IS_LOG_HANDLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_LOG_HANDLER))
#define RYGEL_LOG_HANDLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerClass))

typedef struct _RygelLogHandler RygelLogHandler;
typedef struct _RygelLogHandlerClass RygelLogHandlerClass;
typedef struct _RygelLogHandlerPrivate RygelLogHandlerPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define RYGEL_TYPE_META_CONFIG (rygel_meta_config_get_type ())
#define RYGEL_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfig))
#define RYGEL_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))
#define RYGEL_IS_META_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_META_CONFIG))
#define RYGEL_IS_META_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), RYGEL_TYPE_META_CONFIG))
#define RYGEL_META_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), RYGEL_TYPE_META_CONFIG, RygelMetaConfigClass))

typedef struct _RygelMetaConfig RygelMetaConfig;
typedef struct _RygelMetaConfigClass RygelMetaConfigClass;

#define RYGEL_TYPE_CONFIGURATION (rygel_configuration_get_type ())
#define RYGEL_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfiguration))
#define RYGEL_IS_CONFIGURATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), RYGEL_TYPE_CONFIGURATION))
#define RYGEL_CONFIGURATION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), RYGEL_TYPE_CONFIGURATION, RygelConfigurationIface))

typedef struct _RygelConfiguration RygelConfiguration;
typedef struct _RygelConfigurationIface RygelConfigurationIface;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

typedef enum  {
	RYGEL_LOG_LEVEL_INVALID = 0,
	RYGEL_LOG_LEVEL_CRITICAL = 1,
	RYGEL_LOG_LEVEL_ERROR = 2,
	RYGEL_LOG_LEVEL_WARNING = 3,
	RYGEL_LOG_LEVEL_INFO = 4,
	RYGEL_LOG_LEVEL_DEFAULT = 4,
	RYGEL_LOG_LEVEL_DEBUG = 5
} RygelLogLevel;

struct _RygelLogHandler {
	GObject parent_instance;
	RygelLogHandlerPrivate * priv;
};

struct _RygelLogHandlerClass {
	GObjectClass parent_class;
};

struct _RygelLogHandlerPrivate {
	GeeHashMap* log_level_hash;
};

struct _RygelConfigurationIface {
	GTypeInterface parent_iface;
	gboolean (*get_upnp_enabled) (RygelConfiguration* self, GError** error);
	gchar* (*get_interface) (RygelConfiguration* self, GError** error);
	gint (*get_port) (RygelConfiguration* self, GError** error);
	gboolean (*get_transcoding) (RygelConfiguration* self, GError** error);
	gboolean (*get_allow_upload) (RygelConfiguration* self, GError** error);
	gboolean (*get_allow_deletion) (RygelConfiguration* self, GError** error);
	gchar* (*get_log_levels) (RygelConfiguration* self, GError** error);
	gchar* (*get_plugin_path) (RygelConfiguration* self, GError** error);
	gchar* (*get_engine_path) (RygelConfiguration* self, GError** error);
	gchar* (*get_media_engine) (RygelConfiguration* self, GError** error);
	gchar* (*get_video_upload_folder) (RygelConfiguration* self, GError** error);
	gchar* (*get_music_upload_folder) (RygelConfiguration* self, GError** error);
	gchar* (*get_picture_upload_folder) (RygelConfiguration* self, GError** error);
	gboolean (*get_enabled) (RygelConfiguration* self, const gchar* section, GError** error);
	gchar* (*get_title) (RygelConfiguration* self, const gchar* section, GError** error);
	gchar* (*get_string) (RygelConfiguration* self, const gchar* section, const gchar* key, GError** error);
	GeeArrayList* (*get_string_list) (RygelConfiguration* self, const gchar* section, const gchar* key, GError** error);
	gint (*get_int) (RygelConfiguration* self, const gchar* section, const gchar* key, gint min, gint max, GError** error);
	GeeArrayList* (*get_int_list) (RygelConfiguration* self, const gchar* section, const gchar* key, GError** error);
	gboolean (*get_bool) (RygelConfiguration* self, const gchar* section, const gchar* key, GError** error);
};


static gpointer rygel_log_handler_parent_class = NULL;
static RygelLogHandler* rygel_log_handler_log_handler;
static RygelLogHandler* rygel_log_handler_log_handler = NULL;

GType rygel_log_level_get_type (void) G_GNUC_CONST;
GType rygel_log_handler_get_type (void) G_GNUC_CONST;
#define RYGEL_LOG_HANDLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), RYGEL_TYPE_LOG_HANDLER, RygelLogHandlerPrivate))
enum  {
	RYGEL_LOG_HANDLER_DUMMY_PROPERTY
};
#define RYGEL_LOG_HANDLER_DEFAULT_LEVELS "*:4"
#define RYGEL_LOG_HANDLER_DEFAULT_FLAGS ((((G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR) | G_LOG_LEVEL_MESSAGE) | G_LOG_LEVEL_INFO)
RygelLogHandler* rygel_log_handler_get_default (void);
static RygelLogHandler* rygel_log_handler_new (void);
static RygelLogHandler* rygel_log_handler_construct (GType object_type);
GType rygel_meta_config_get_type (void) G_GNUC_CONST;
RygelMetaConfig* rygel_meta_config_get_default (void);
GType rygel_configuration_get_type (void) G_GNUC_CONST;
gchar* rygel_configuration_get_log_levels (RygelConfiguration* self, GError** error);
static GLogLevelFlags rygel_log_handler_log_level_to_flags (RygelLogHandler* self, RygelLogLevel level);
static void rygel_log_handler_log_func (RygelLogHandler* self, const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message);
static void _rygel_log_handler_log_func_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
static void rygel_log_handler_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GType rygel_log_level_get_type (void) {
	static volatile gsize rygel_log_level_type_id__volatile = 0;
	if (g_once_init_enter (&rygel_log_level_type_id__volatile)) {
		static const GEnumValue values[] = {{RYGEL_LOG_LEVEL_INVALID, "RYGEL_LOG_LEVEL_INVALID", "invalid"}, {RYGEL_LOG_LEVEL_CRITICAL, "RYGEL_LOG_LEVEL_CRITICAL", "critical"}, {RYGEL_LOG_LEVEL_ERROR, "RYGEL_LOG_LEVEL_ERROR", "error"}, {RYGEL_LOG_LEVEL_WARNING, "RYGEL_LOG_LEVEL_WARNING", "warning"}, {RYGEL_LOG_LEVEL_INFO, "RYGEL_LOG_LEVEL_INFO", "info"}, {RYGEL_LOG_LEVEL_DEFAULT, "RYGEL_LOG_LEVEL_DEFAULT", "default"}, {RYGEL_LOG_LEVEL_DEBUG, "RYGEL_LOG_LEVEL_DEBUG", "debug"}, {0, NULL, NULL}};
		GType rygel_log_level_type_id;
		rygel_log_level_type_id = g_enum_register_static ("RygelLogLevel", values);
		g_once_init_leave (&rygel_log_level_type_id__volatile, rygel_log_level_type_id);
	}
	return rygel_log_level_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


RygelLogHandler* rygel_log_handler_get_default (void) {
	RygelLogHandler* result = NULL;
	RygelLogHandler* _tmp0_;
	RygelLogHandler* _tmp2_;
	RygelLogHandler* _tmp3_;
	_tmp0_ = rygel_log_handler_log_handler;
	if (_tmp0_ == NULL) {
		RygelLogHandler* _tmp1_;
		_tmp1_ = rygel_log_handler_new ();
		_g_object_unref0 (rygel_log_handler_log_handler);
		rygel_log_handler_log_handler = _tmp1_;
	}
	_tmp2_ = rygel_log_handler_log_handler;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


static void _rygel_log_handler_log_func_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	rygel_log_handler_log_func (self, log_domain, log_levels, message);
}


static RygelLogHandler* rygel_log_handler_construct (GType object_type) {
	RygelLogHandler * self = NULL;
	GeeHashMap* _tmp0_;
	RygelMetaConfig* _tmp1_ = NULL;
	RygelMetaConfig* config;
	gchar* log_levels = NULL;
	const gchar* _tmp9_;
	gchar** _tmp10_;
	gchar** _tmp11_ = NULL;
	GError * _inner_error_ = NULL;
	self = (RygelLogHandler*) g_object_new (object_type, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_INT, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->log_level_hash);
	self->priv->log_level_hash = _tmp0_;
	_tmp1_ = rygel_meta_config_get_default ();
	config = _tmp1_;
	{
		RygelMetaConfig* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp2_ = config;
		_tmp3_ = rygel_configuration_get_log_levels ((RygelConfiguration*) _tmp2_, &_inner_error_);
		_tmp4_ = _tmp3_;
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
		}
		_g_free0 (log_levels);
		log_levels = _tmp4_;
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* err = NULL;
		gchar* _tmp5_;
		const gchar* _tmp6_ = NULL;
		GError* _tmp7_;
		const gchar* _tmp8_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = g_strdup (RYGEL_LOG_HANDLER_DEFAULT_LEVELS);
		_g_free0 (log_levels);
		log_levels = _tmp5_;
		_tmp6_ = _ ("Failed to get log level from configuration: %s");
		_tmp7_ = err;
		_tmp8_ = _tmp7_->message;
		g_warning (_tmp6_, _tmp8_);
		_g_error_free0 (err);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_free0 (log_levels);
		_g_object_unref0 (config);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp9_ = log_levels;
	_tmp11_ = _tmp10_ = g_strsplit (_tmp9_, ",", 0);
	{
		gchar** pair_collection = NULL;
		gint pair_collection_length1 = 0;
		gint _pair_collection_size_ = 0;
		gint pair_it = 0;
		pair_collection = _tmp11_;
		pair_collection_length1 = _vala_array_length (_tmp10_);
		for (pair_it = 0; pair_it < _vala_array_length (_tmp10_); pair_it = pair_it + 1) {
			gchar* _tmp12_;
			gchar* pair = NULL;
			_tmp12_ = g_strdup (pair_collection[pair_it]);
			pair = _tmp12_;
			{
				const gchar* _tmp13_;
				gchar** _tmp14_;
				gchar** _tmp15_ = NULL;
				gchar** tokens;
				gint tokens_length1;
				gint _tokens_size_;
				gchar** _tmp16_;
				gint _tmp16__length1;
				gchar* domain = NULL;
				RygelLogLevel level = 0;
				gchar** _tmp17_;
				gint _tmp17__length1;
				RygelLogLevel _tmp28_;
				GLogLevelFlags _tmp29_ = 0;
				GLogLevelFlags flags;
				GeeHashMap* _tmp30_;
				const gchar* _tmp31_;
				GLogLevelFlags _tmp32_;
				_tmp13_ = pair;
				_tmp15_ = _tmp14_ = g_strsplit (_tmp13_, ":", 0);
				tokens = _tmp15_;
				tokens_length1 = _vala_array_length (_tmp14_);
				_tokens_size_ = tokens_length1;
				_tmp16_ = tokens;
				_tmp16__length1 = tokens_length1;
				if (_tmp16__length1 < 1) {
					tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (pair);
					break;
				}
				_tmp17_ = tokens;
				_tmp17__length1 = tokens_length1;
				if (_tmp17__length1 == 1) {
					gchar** _tmp18_;
					gint _tmp18__length1;
					const gchar* _tmp19_;
					gint _tmp20_ = 0;
					gchar* _tmp21_;
					_tmp18_ = tokens;
					_tmp18__length1 = tokens_length1;
					_tmp19_ = _tmp18_[0];
					_tmp20_ = atoi (_tmp19_);
					level = (RygelLogLevel) _tmp20_;
					_tmp21_ = g_strdup ("*");
					_g_free0 (domain);
					domain = _tmp21_;
				} else {
					gchar** _tmp22_;
					gint _tmp22__length1;
					const gchar* _tmp23_;
					gchar* _tmp24_;
					gchar** _tmp25_;
					gint _tmp25__length1;
					const gchar* _tmp26_;
					gint _tmp27_ = 0;
					_tmp22_ = tokens;
					_tmp22__length1 = tokens_length1;
					_tmp23_ = _tmp22_[0];
					_tmp24_ = g_strdup (_tmp23_);
					_g_free0 (domain);
					domain = _tmp24_;
					_tmp25_ = tokens;
					_tmp25__length1 = tokens_length1;
					_tmp26_ = _tmp25_[1];
					_tmp27_ = atoi (_tmp26_);
					level = (RygelLogLevel) _tmp27_;
				}
				_tmp28_ = level;
				_tmp29_ = rygel_log_handler_log_level_to_flags (self, _tmp28_);
				flags = _tmp29_;
				_tmp30_ = self->priv->log_level_hash;
				_tmp31_ = domain;
				_tmp32_ = flags;
				gee_abstract_map_set ((GeeAbstractMap*) _tmp30_, _tmp31_, (gpointer) ((gintptr) _tmp32_));
				_g_free0 (domain);
				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (pair);
			}
		}
		pair_collection = (_vala_array_free (pair_collection, pair_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	g_log_set_default_handler (_rygel_log_handler_log_func_glog_func, self);
	_g_free0 (log_levels);
	_g_object_unref0 (config);
	return self;
}


static RygelLogHandler* rygel_log_handler_new (void) {
	return rygel_log_handler_construct (RYGEL_TYPE_LOG_HANDLER);
}


static void rygel_log_handler_log_func (RygelLogHandler* self, const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message) {
	GLogLevelFlags flags;
	const gchar* _tmp0_;
	GLogLevelFlags _tmp4_;
	GLogLevelFlags _tmp7_;
	GLogLevelFlags _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	flags = 0;
	_tmp0_ = log_domain;
	if (_tmp0_ != NULL) {
		GeeHashMap* _tmp1_;
		const gchar* _tmp2_;
		gpointer _tmp3_ = NULL;
		_tmp1_ = self->priv->log_level_hash;
		_tmp2_ = log_domain;
		_tmp3_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp1_, _tmp2_);
		flags = (GLogLevelFlags) ((gintptr) _tmp3_);
	}
	_tmp4_ = flags;
	if (_tmp4_ == 0) {
		GeeHashMap* _tmp5_;
		gpointer _tmp6_ = NULL;
		_tmp5_ = self->priv->log_level_hash;
		_tmp6_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp5_, "*");
		flags = (GLogLevelFlags) ((gintptr) _tmp6_);
	}
	_tmp7_ = log_levels;
	_tmp8_ = flags;
	if ((_tmp8_ & _tmp7_) == _tmp7_) {
		GLogFunc _tmp9_;
		void* _tmp9__target;
		const gchar* _tmp10_;
		GLogLevelFlags _tmp11_;
		const gchar* _tmp12_;
		_tmp9_ = g_log_default_handler;
		_tmp9__target = NULL;
		_tmp10_ = log_domain;
		_tmp11_ = log_levels;
		_tmp12_ = message;
		_tmp9_ (_tmp10_, _tmp11_, _tmp12_, _tmp9__target);
	}
}


static GLogLevelFlags rygel_log_handler_log_level_to_flags (RygelLogHandler* self, RygelLogLevel level) {
	GLogLevelFlags result = 0;
	GLogLevelFlags flags;
	RygelLogLevel _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	flags = RYGEL_LOG_HANDLER_DEFAULT_FLAGS;
	_tmp0_ = level;
	switch (_tmp0_) {
		case RYGEL_LOG_LEVEL_CRITICAL:
		{
			flags = G_LOG_LEVEL_CRITICAL;
			break;
		}
		case RYGEL_LOG_LEVEL_ERROR:
		{
			flags = G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_ERROR;
			break;
		}
		case RYGEL_LOG_LEVEL_WARNING:
		{
			flags = (G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR;
			break;
		}
		case RYGEL_LOG_LEVEL_INFO:
		{
			flags = (((G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR) | G_LOG_LEVEL_MESSAGE) | G_LOG_LEVEL_INFO;
			break;
		}
		case RYGEL_LOG_LEVEL_DEBUG:
		{
			flags = ((((G_LOG_LEVEL_WARNING | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR) | G_LOG_LEVEL_MESSAGE) | G_LOG_LEVEL_INFO) | G_LOG_LEVEL_DEBUG;
			break;
		}
		default:
		{
			flags = RYGEL_LOG_HANDLER_DEFAULT_FLAGS;
			break;
		}
	}
	result = flags;
	return result;
}


static void rygel_log_handler_class_init (RygelLogHandlerClass * klass) {
	rygel_log_handler_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (RygelLogHandlerPrivate));
	G_OBJECT_CLASS (klass)->finalize = rygel_log_handler_finalize;
}


static void rygel_log_handler_instance_init (RygelLogHandler * self) {
	self->priv = RYGEL_LOG_HANDLER_GET_PRIVATE (self);
}


static void rygel_log_handler_finalize (GObject* obj) {
	RygelLogHandler * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, RYGEL_TYPE_LOG_HANDLER, RygelLogHandler);
	_g_object_unref0 (self->priv->log_level_hash);
	G_OBJECT_CLASS (rygel_log_handler_parent_class)->finalize (obj);
}


GType rygel_log_handler_get_type (void) {
	static volatile gsize rygel_log_handler_type_id__volatile = 0;
	if (g_once_init_enter (&rygel_log_handler_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RygelLogHandlerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) rygel_log_handler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RygelLogHandler), 0, (GInstanceInitFunc) rygel_log_handler_instance_init, NULL };
		GType rygel_log_handler_type_id;
		rygel_log_handler_type_id = g_type_register_static (G_TYPE_OBJECT, "RygelLogHandler", &g_define_type_info, 0);
		g_once_init_leave (&rygel_log_handler_type_id__volatile, rygel_log_handler_type_id);
	}
	return rygel_log_handler_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



